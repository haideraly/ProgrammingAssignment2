inv
}
}
}
}
}
inv
list(set = set, get = get,
## Put comments here that give an overall description of what your
makeCacheMatrix <- function(x = matrix()) {
source('C:/Users/HaiderDesktop/rprogass-repo/ProgrammingAssignment2/cachematrix.R')
m <- matrix(1:4, nrow = 2, ncol = 2)
makeCacheMatrix(m)
a <- makeCacheMatrix(m)
a$getinv()
a$get()
a$cacheSolve(a)
cacheSolve(a)
fix(cacheSolve)
source('C:/Users/HaiderDesktop/rprogass-repo/ProgrammingAssignment2/cachematrix.R')
fix(cacheSolve)
cacheSolve(a)
cacheSolve(a)
m2 <- matrix(5:8, nrow = 2, ncol = 2)
m2
b <- makeCacheMatrix(m2)
b$get
b$get()
g$getinv()
b$getinv()
b$getinv()
a$getinv()
b$getinv()
a <- makeCacheMatrix(matrix(5:8, nrow = 2, ncol = 2))
a$get()
a$getinv()
## Put comments here that give an overall description of what your
## functions do
## Write a short comment describing this function
makeCacheMatrix <- function(x = matrix()) {
Solveinv <- NULL
set <- function(y) {
x <<- y
inv <<- NULL
}
get <- function() x
setinv <- function(solve) inv <<- solve
getinv <- function() inv
list(set = set, get = get,
setinv = setinv,
getinv = getinv)
}
## Write a short comment describing this function
cacheSolve <- function(x, ...) {
## Return a matrix that is the inverse of 'x'
inv <- x$getinv()
if(!is.null(inv)) {
message("getting cached data")
return(inv)
}
data <- x$get()
inv <- solve(data, ...)
x$setinv(inv)
inv
}
a <- makeCacheMatrix(matrix(5:8, nrow = 2, ncol = 2))
a$get()
a$getinv()
cacheSolve(a)
source('C:/Users/HaiderDesktop/rprogass-repo/ProgrammingAssignment2/cachematrix.R')
## Put comments here that give an overall description of what your
## functions do
## Write a short comment describing this function
makeCacheMatrix <- function(x = matrix()) {
inv <- NULL
set <- function(y) {
x <<- y
inv <<- NULL
}
get <- function() x
setinv <- function(solve) inv <<- solve
getinv <- function() inv
list(set = set, get = get,
setinv = setinv,
getinv = getinv)
}
## Write a short comment describing this function
cacheSolve <- function(x, ...) {
## Return a matrix that is the inverse of 'x'
inv <- x$getinv()
if(!is.null(inv)) {
message("getting cached data")
return(inv)
}
data <- x$get()
inv <- solve(data, ...)
x$setinv(inv)
inv
}
a <- makeCacheMatrix(matrix(5:8, nrow = 2, ncol = 2))
a$get
a$get()
a$getinv()
cacheSolve(a)
a$getinv()
cacheSolve(a)
b <- makeCacheMatrix(matrix(3:11, nrow = 3, ncol = 3))
b$get()
b$getinv()
cacheSolve(b)
b$getinv()
b <- makeCacheMatrix(matrix(1:4, nrow = 2, ncol = 2))
b$get()
b$getinv()
cacheSolve(b)
cacheSolve(b)
b$getinv
b$getinv()
class(makeCachematrix)
class(makeCacheMatrix)
source('C:/Users/HaiderDesktop/rprogass-repo/ProgrammingAssignment2/cachematrix.R')
##The following 2 functions are used to create a special object
##that stores a matrix and cache's its inverse.
##The following function creates a matrix which is a part of
##a list containing 4 functions to:
##1 initialize the matrix
##2 get the values of matrix
##3 set the value of matrix inverse "inv"
##4 get the value of matrix inverse "inv"
makeCacheMatrix <- function(x = matrix()) {
inv <- NULL
set <- function(y) {
x <<- y
inv <<- NULL
}
get <- function() x
setinv <- function(solve) inv <<- solve
getinv <- function() inv
list(set = set, get = get,
setinv = setinv,
getinv = getinv)
}
##The following function creates the inverse of the matrix
##created in the above function. However, it checks to see
##if the inverse has already been calculated. When there is
##a valid inverse value it skips the calculation returns the
##stored/cached value of the inverse.
cacheSolve <- function(x, ...) {
## Return a matrix that is the inverse of 'x'
inv <- x$getinv()
if(!is.null(inv)) {
message("getting cached data")
return(inv)
}
data <- x$get()
inv <- solve(data, ...)
x$setinv(inv)
inv
}
b <- makeCacheMatrix()
b$get()
b$set(matrix(1:4, nrow = 2, ncol =2))
b$get()
b$getinv()
cacheSolve(b)
cacheSolve(b)
b$getinv()
source('C:/Users/HaiderDesktop/rprogass-repo/ProgrammingAssignment2/cachematrix.R')
